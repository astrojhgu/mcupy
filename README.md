# pymcutil
This is a python binding for mcmc_utilities <br/>

##Instalation
This lib relies on<br/>

1. ![astrojhgu/mcmc_utilities](https://github.com/astrojhgu/mcmc_utilities): the core part for describing the graph structure of bayesian networks<br/>
2. ![astrojhgu/coscalcpp](https://github.com/astrojhgu/coscalcpp): for performing cosmology calculation (this library is actually for astronomer<br/>
3. ![astrojhgu/east](https://github.com/astrojhgu/east): parsing expression<br/>

Be sure to puth all above three libs and this lib in the same parent directory.<br/>

And it relies on ![boost](https://github.com/boostorg/boost)<br/>

After above libs are installed, just execute go into pymcutil and run
```shell
./setup.sh build
./setup.sh install # as root if needed
```

##Example
Check ![example/estimate_eff/estimate_eff.py](example/estimate_eff/estimate_eff.py).<br/>
This is an example given in thie book ![BAYESIAN METHODS FOR THE PHYSICAL SCIENCES](http://www.brera.mi.astro.it/~andreon/BayesianMethodsForThePhysicalSciences/) section 8.2.

```python
#!/usr/bin/env python

import sys
```
Import the mcmc package
```python
import mcmc
```

Create a class to represent the graph structure of the Bayesian network<br/>
The structure of the Bayesian network should be defined in ```__init__```
```python
class Graph(mcmc.BaseGraphComposer):
    def __init__(self):
```
(Optionally) create an array of monitor to record the result of each sampling step
```python
        self.monitors=[]
```
Call the constructor of the base class first
```python
        super(Graph,self).__init__()
```
Create new nodes with an optional tag ```'A'```
```python
        A=self.uniform(0.001,1-1e-5,'A')
        B=self.uniform(0.001,1-1e-5,'B')
        mu=self.uniform(.001,100-1e-5,'mu')
        sigma=self.uniform(.001,100-1e-5,'sigma')
```
Add a monitor
```python
        self.monitors.append(A[0].monitor())
        self.monitors.append(B[0].monitor())
        self.monitors.append(mu[0].monitor())
        self.monitors.append(sigma[0].monitor())
```
Node definition in a loop
```python
        n=0
        for l in open('eff.txt'):
            e1,nrec1,ninj1=l.split()
            e1=float(e1)
            nrec1=float(nrec1)
            ninj1=float(ninj1)
```
You can use ```("E",n)``` as the tag, so that all ```("E",n)``` will be regarded as a group
```python
            E=self.const(e1,("E",n))
            ninj=self.const(ninj1,("ninj",n))
            eff=(B-A)*self.phi((E-mu)/sigma)+A
            #eff=self.func("(B-A)*phi((E-mu)/sigma)+A",("E","A","B","mu","sigma"),(E,A,B,mu,sigma),("eff",n))
            nrec=self.binary(eff,ninj,("nrec",n))
            nrec.set_value(0,nrec1)
            nrec.set_observed(0,True)
            n+=1
```
After the class for the Bayesian is defined, create an instance
```python
g=Graph()
```
Let's first dump the topology of the bayesian and have a look
```python
g.graph.dump_topology("eff.dot")
```
Another method of creating the monitor
```python
A=g.monitor("A",0)
B=g.monitor("B",0)
mu=g.monitor("mu",0)
sigma=g.monitor("sigma",0)
```
Run 100 times of sampling for burning
```python
for i in range(0,100):
    g.sample()
```
Run for 30000 times and output the results to stdout
```python
for i in range(0,30000):
    g.sample()
    v=' '.join(['{0}'.format(i()) for i in g.monitors])
    print(v)
```

Let's check the ![eff.dot](example/estimate_eff/eff.dot) file generated by the test.py, it can be parsed by graphviz command dot as
```
dot eff.dot -T svg -o eff.svg
```
it will generate ![eff.svg](example/estimate_eff/eff.svg) as <br/>
![eff.svg](https://raw.githubusercontent.com/astrojhgu/pymcutil/master/example/estimate_eff/eff.png)
